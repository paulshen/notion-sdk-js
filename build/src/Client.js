var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Client_auth, _Client_logLevel, _Client_logger, _Client_got;
// import type { Agent } from "http"
// import { URL } from "url"
import { LogLevel, logLevelSeverity, makeConsoleLogger, } from "./logging";
import { buildRequestError, HTTPResponseError } from "./errors";
import { pick } from "./helpers";
import { blocksChildrenAppend, blocksChildrenList, databasesList, databasesQuery, databasesRetrieve, pagesCreate, pagesRetrieve, pagesUpdate, usersList, usersRetrieve, search, } from "./api-endpoints";
import got from "https://cdn.skypack.dev/ky";
export default class Client {
    constructor(options) {
        var _a, _b, _c, _d, _e;
        _Client_auth.set(this, void 0);
        _Client_logLevel.set(this, void 0);
        _Client_logger.set(this, void 0);
        _Client_got.set(this, void 0);
        /*
         * Notion API endpoints
         */
        this.blocks = {
            children: {
                /**
                 * Append block children
                 */
                append: (args) => {
                    return this.request({
                        path: blocksChildrenAppend.path(args),
                        method: blocksChildrenAppend.method,
                        query: pick(args, blocksChildrenAppend.queryParams),
                        body: pick(args, blocksChildrenAppend.bodyParams),
                        auth: args === null || args === void 0 ? void 0 : args.auth,
                    });
                },
                /**
                 * Retrieve block children
                 */
                list: (args) => {
                    return this.request({
                        path: blocksChildrenList.path(args),
                        method: blocksChildrenList.method,
                        query: pick(args, blocksChildrenList.queryParams),
                        body: pick(args, blocksChildrenList.bodyParams),
                        auth: args === null || args === void 0 ? void 0 : args.auth,
                    });
                },
            },
        };
        this.databases = {
            /**
             * List databases
             *
             * @deprecated Please use `search`
             */
            list: (args = {}) => {
                return this.request({
                    path: databasesList.path(),
                    method: databasesList.method,
                    query: pick(args, databasesList.queryParams),
                    body: pick(args, databasesList.bodyParams),
                    auth: args === null || args === void 0 ? void 0 : args.auth,
                });
            },
            /**
             * Retrieve a database
             */
            retrieve: (args) => {
                return this.request({
                    path: databasesRetrieve.path(args),
                    method: databasesRetrieve.method,
                    query: pick(args, databasesRetrieve.queryParams),
                    body: pick(args, databasesRetrieve.bodyParams),
                    auth: args === null || args === void 0 ? void 0 : args.auth,
                });
            },
            /**
             * Query a database
             */
            query: (args) => {
                return this.request({
                    path: databasesQuery.path(args),
                    method: databasesQuery.method,
                    query: pick(args, databasesQuery.queryParams),
                    body: pick(args, databasesQuery.bodyParams),
                    auth: args === null || args === void 0 ? void 0 : args.auth,
                });
            },
        };
        this.pages = {
            /**
             * Create a page
             */
            create: (args) => {
                return this.request({
                    path: pagesCreate.path(),
                    method: pagesCreate.method,
                    query: pick(args, pagesCreate.queryParams),
                    body: pick(args, pagesCreate.bodyParams),
                    auth: args === null || args === void 0 ? void 0 : args.auth,
                });
            },
            /**
             * Retrieve a page
             */
            retrieve: (args) => {
                return this.request({
                    path: pagesRetrieve.path(args),
                    method: pagesRetrieve.method,
                    query: pick(args, pagesRetrieve.queryParams),
                    body: pick(args, pagesRetrieve.bodyParams),
                    auth: args === null || args === void 0 ? void 0 : args.auth,
                });
            },
            /**
             * Update page properties
             */
            update: (args) => {
                return this.request({
                    path: pagesUpdate.path(args),
                    method: pagesUpdate.method,
                    query: pick(args, pagesUpdate.queryParams),
                    body: pick(args, pagesUpdate.bodyParams),
                    auth: args === null || args === void 0 ? void 0 : args.auth,
                });
            },
        };
        this.users = {
            /**
             * Retrieve a user
             */
            retrieve: (args) => {
                return this.request({
                    path: usersRetrieve.path(args),
                    method: usersRetrieve.method,
                    query: pick(args, usersRetrieve.queryParams),
                    body: pick(args, usersRetrieve.bodyParams),
                    auth: args === null || args === void 0 ? void 0 : args.auth,
                });
            },
            /**
             * List all users
             */
            list: (args = {}) => {
                return this.request({
                    path: usersList.path(),
                    method: usersList.method,
                    query: pick(args, usersList.queryParams),
                    body: pick(args, usersList.bodyParams),
                    auth: args === null || args === void 0 ? void 0 : args.auth,
                });
            },
        };
        __classPrivateFieldSet(this, _Client_auth, options === null || options === void 0 ? void 0 : options.auth, "f");
        __classPrivateFieldSet(this, _Client_logLevel, (_a = options === null || options === void 0 ? void 0 : options.logLevel) !== null && _a !== void 0 ? _a : LogLevel.WARN, "f");
        __classPrivateFieldSet(this, _Client_logger, (_b = options === null || options === void 0 ? void 0 : options.logger) !== null && _b !== void 0 ? _b : makeConsoleLogger(this.constructor.name), "f");
        const prefixUrl = ((_c = options === null || options === void 0 ? void 0 : options.baseUrl) !== null && _c !== void 0 ? _c : "https://api.notion.com") + "/v1/";
        const timeout = (_d = options === null || options === void 0 ? void 0 : options.timeoutMs) !== null && _d !== void 0 ? _d : 60000;
        const notionVersion = (_e = options === null || options === void 0 ? void 0 : options.notionVersion) !== null && _e !== void 0 ? _e : Client.defaultNotionVersion;
        __classPrivateFieldSet(this, _Client_got, got.extend({
            prefixUrl,
            timeout,
            headers: {
                "Notion-Version": notionVersion,
                // TODO: update with format appropriate for telemetry, use version from package.json
                "user-agent": "notionhq-client/0.1.0",
            },
            retry: 0,
            // agent: makeAgentOption(prefixUrl, options?.agent),
        }), "f");
    }
    /**
     * Sends a request.
     *
     * @param path
     * @param method
     * @param query
     * @param body
     * @returns
     */
    async request({ path, method, query, body, auth, }) {
        this.log(LogLevel.INFO, "request start", { method, path });
        // If the body is empty, don't send the body in the HTTP request
        const json = body !== undefined && Object.entries(body).length === 0 ? undefined : body;
        try {
            const response = await __classPrivateFieldGet(this, _Client_got, "f").call(this, path, {
                method,
                searchParams: query,
                json,
                headers: this.authAsHeaders(auth),
            }).json();
            this.log(LogLevel.INFO, `request success`, { method, path });
            return response;
        }
        catch (error) {
            // Build an error of a known type, otherwise throw unexpected errors
            const requestError = buildRequestError(error);
            if (requestError === undefined) {
                throw error;
            }
            this.log(LogLevel.WARN, `request fail`, {
                code: requestError.code,
                message: requestError.message,
            });
            if (HTTPResponseError.isHTTPResponseError(requestError)) {
                // The response body may contain sensitive information so it is logged separately at the DEBUG level
                this.log(LogLevel.DEBUG, `failed response body`, {
                // body: requestError.body,
                });
            }
            // Throw as a known error type
            throw requestError;
        }
    }
    /**
     * Search
     */
    search(args) {
        return this.request({
            path: search.path(),
            method: search.method,
            query: pick(args, search.queryParams),
            body: pick(args, search.bodyParams),
            auth: args === null || args === void 0 ? void 0 : args.auth,
        });
    }
    /**
     * Emits a log message to the console.
     *
     * @param level The level for this message
     * @param args Arguments to send to the console
     */
    log(level, message, extraInfo) {
        if (logLevelSeverity(level) >= logLevelSeverity(__classPrivateFieldGet(this, _Client_logLevel, "f"))) {
            __classPrivateFieldGet(this, _Client_logger, "f").call(this, level, message, extraInfo);
        }
    }
    /**
     * Transforms an API key or access token into a headers object suitable for an HTTP request.
     *
     * This method uses the instance's value as the default when the input is undefined. If neither are defined, it returns
     * an empty object
     *
     * @param auth API key or access token
     * @returns headers key-value object
     */
    authAsHeaders(auth) {
        const headers = {};
        const authHeaderValue = auth !== null && auth !== void 0 ? auth : __classPrivateFieldGet(this, _Client_auth, "f");
        if (authHeaderValue !== undefined) {
            headers["authorization"] = `Bearer ${authHeaderValue}`;
        }
        return headers;
    }
}
_Client_auth = new WeakMap(), _Client_logLevel = new WeakMap(), _Client_logger = new WeakMap(), _Client_got = new WeakMap();
Client.defaultNotionVersion = "2021-05-13";
/*
 * Helper functions
 */
// function makeAgentOption(
//   prefixUrl: string,
//   agent: Agent | undefined
// ): GotAgents | undefined {
//   if (agent === undefined) {
//     return undefined
//   }
//   return {
//     [selectProtocol(prefixUrl)]: agent,
//   }
// }
// function selectProtocol(prefixUrl: string): "http" | "https" {
//   const url = new URL(prefixUrl)
//   if (url.protocol === "https:") {
//     return "https"
//   } else if (url.protocol === "http:") {
//     return "http"
//   }
//   throw new TypeError(`baseUrl option must begin with "https://" or "http://"`)
// }
//# sourceMappingURL=Client.js.map